
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="keywords" content="remark,remarkjs,markdown,slideshow,presentation" />
    <meta name="description" content="A simple, in-browser, markdown-driven slideshow tool." />
    <title>Strategies for code correctness inspired by functional programming</title>
    <style>
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif);
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body {
        font-family: 'Droid Serif';
      }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: 400;
        margin-bottom: 0;
      }
      .remark-slide-content {
        padding-left: 2em;
        padding-right: 2em;
        padding-top: 0em;
      }
      .remark-slide-content h1 { font-size: 3em; }
      .remark-slide-content h2 { font-size: 2em; }
      .remark-slide-content h3 { font-size: 1.6em; }
      .footnote {
        position: absolute;
        bottom: 3em;
      }
      li p { line-height: 1.25em; }
      .red { color: #fa0000; }
      .large { font-size: 2em; }
      a, a > code {
        color: rgb(249, 38, 114);
        text-decoration: none;
      }
      code {
        background: #e7e8e2;
        border-radius: 5px;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
      .remark-code { font-size: 120%; }
      .remark-code-line-highlighted     { background-color: #373832; }
      .pull-left {
        float: left;
        width: 47%;
      }
      .pull-right {
        float: right;
        width: 47%;
      }
      .pull-right ~ p {
        clear: both;
      }
      #slideshow .slide .content code {
        font-size: 0.8em;
      }
      #slideshow .slide .content pre code {
        font-size: 0.9em;
        padding: 15px;
      }
      .inverse {
        background: #272822;
        color: #777872;
        text-shadow: 0 0 20px #333;
      }
      .inverse h1, .inverse h2 {
        color: #f3f3f3;
        line-height: 0.8em;
      }

      /* Slide-specific styling */
      #slide-inverse .footnote {
        bottom: 12px;
        left: 20px;
      }
      #slide-how .slides {
        font-size: 0.9em;
        position: absolute;
        top:  151px;
        right: 140px;
      }
      #slide-how .slides h3 {
        margin-top: 0.2em;
      }
      #slide-how .slides .first, #slide-how .slides .second {
        padding: 1px 20px;
        height: 90px;
        width: 120px;
        -moz-box-shadow: 0 0 10px #777;
        -webkit-box-shadow: 0 0 10px #777;
        box-shadow: 0 0 10px #777;
      }
      #slide-how .slides .first {
        background: #fff;
        position: absolute;
        top: 20%;
        left: 20%;
        z-index: 1;
      }
      #slide-how .slides .second {
        position: relative;
        background: #fff;
        z-index: 0;
      }

      /* Two-column layout */
      .left-column {
        color: #777;
        width: 20%;
        height: 92%;
        float: left;
      }
        .left-column h2:last-of-type, .left-column h3:last-child {
          color: #000;
        }
      .right-column {
        width: 75%;
        float: right;
        padding-top: 0.5em;
        font-size: 125%;
      }
      .smaller img {
          width: 15%;
          height: auto;
      }
      .smaller20 img {
          width: 20%;
          height: auto;
      }
    </style>
  </head>
  <body>
    <textarea id="source">
layout: true
class: center, middle
---
# Strategies for Code Correctness
##Inspired by <span style="color:purple">Functional Frogramming</span>

![](images/function.png)

##  <span style="color:blue">@chrismwendt</span> / GitHub Engineering All-Hands Meeting 2015-10-22

???

"Strategies for Code Correctness"

This was a highly requested topic from the last All-Hands meeting, and it also happens to be something that functional programming is extremely good at.

So in this presentation, I would like to show you some examples of using functional concepts in Ruby, as well as give you a taste of what can be done in a statically typed language like Haskell.

I hope these concepts will better equip you to avoid bugs in your own projects!
---
# Chris Wendt - @chrismwendt

![](images/contributions.png)

![](images/haskell.png)

![](images/idris.png)

???

I'm @chrismwendt, and as evidenced by my contributions graph, I joined GitHub about 2 months ago. I work with Tim Pease and Grant Rodgers on the Search team.

Haskell was my introduction to functional programming about 2 years ago, and now almost half of my projects are written in it. More recently, I've dabbled in Idris, a language in which you can embed proofs into your programs that get checked at compile time.

Ok, now let's take a look at a few examples of how a functional programming style can be applied to Ruby to reduce complexity and avoid bugs.
---
layout: false
.left-column[
### `map`, `select`, and `reduce`
]
.right-column[
```ruby
def sum_of_even_squares(array)
  sum = 0
  for n in array
    square = n * n
    if square.even?
      sum += square
    end
  end
  sum
end
```

```ruby
def sum_of_even_squares(array)
  array
    .map { |n| n * n }
    .select { |n| n.even? }
    .reduce(0) { |sum, n| sum + n }
end
```
]

???

Here we have 2 implementations of a function which calculates the sum of the even squares of numbers in an array.

The first takes an imperative approach, with the mutable variable `sum`, a `for` loop, and the addition statement guarded by an `if`.

The second takes a declarative approach by employing composability, lambdas, and the common array transformation functions `map`, `select`, and `reduce`.

The functional version is:

- More visually appealing with less nesting
- Simpler because there are fewer variables in scope
- Simpler because the scopes of the transformations are isolated from each other
- Easier to modify (for example, returning just the even squares would be as simple as removing the `reduce` line)

The functional version requires you to know about `map`, `select`, and `reduce`, but the benefit of making it easier to understand once you do is worth it because these functions are so common.
---
.left-column[
### `map`, `select`, and `reduce`
### Pure functions
]
.right-column[
## Pure
- Math `+`, `cos`, `sqrt`
- String operations `split`, `MD5.hexdigest`, `reverse`

## Impure
- IO `gets`, `File.write`, `HTTP::get`, `%x{rm -rf /}`
- Nondeterminism `rand`, `Time.now`
- `$global` mutable state
]

???

A pure function is one which returns the same value given the same arguments, and does not cause side effects. **Examples**

When you can, try to separate pure functions from impure code because pure functions are:

- Easier to test: call them and check the return value.

- Portable since their only dependencies are their arguments, not the presence of a file, a database, or a web service.

- Trivially parallelizable and their return values are cacheable.
---
.left-column[
### `map`, `select`, and `reduce`
### Pure functions
]
.right-column[
```ruby
def truncate_lines
  n = ARGV[0].to_i
  puts($stdin.readlines.map { |line| line[0...n] })
end

def main
  truncate_lines
end
```

```ruby
def truncate_lines(n, lines)
  lines.map { |line| line[0...n] })
end

def main
  puts(truncate_lines(ARGV[0].to_i, $stdin.readlines))
end
```
]

???

Here we have 2 implementations of a program which truncates lines from `stdin` to the length specified by a command line argument.

The first mixes IO with pure computation, and is unnecessarily difficult to test because of that. You would have to run this program in a separate process to test it. `truncate_lines` is **impure** because it reads external state and performs side effects, namely reading from `ARGV` and `stdin`, and writing to `stdout`. Also, it's not a function because it doesn't take arguments. It's more appropriately called a "procedure", "subroutine", or "action".

The second implementation restricts all of the IO to the main method, cleanly extracting out the pure computation as the `truncate_lines` method. This `truncate_lines` is **pure** because it returns the same value given the same arguments.
---
.left-column[
### `map`, `select`, and `reduce`
### Pure functions
### Composition
]
.right-column[
```ruby
def parse_query(string)
  filters = []
  until scanner.eos?
    if scanner.scan('([a-z]+):([a-z]+)')
      filters << {
        :key   => scanner[0],
        :value => scanner[1] }
    elsif ...
  end
  filters
end
```

```ruby
class QueryParser < Parslet::Parser
  rule(:word) { match('[a-z]+') }
  rule(:filter) { (word.as(:key) >>
    word.as(:value)).as(:filter) }
  rule(:query) { (filter | ...).repeat }
  root(:query)
end
```
]

???

Now for a real-world example: parsing the query from the text in a search box on GitHub. These examples were gleaned from real production code - the current version is on top and the new version is on the bottom.

The current version parses a string as a query directly by scanning for matching regexes and appends them to an array until the end of string is reached.

The current version is not composable, so it cannot be easily reused. For example, you couldn't implement nested filters (like and, or, not) by calling `parse_query` recursively.

The new version uses a parser expression library to define the parser. With this approach, the query parser is built up by starting with primitive parsers and then combining them in various ways (like sequencing and alternation).
---
.left-column[
### `map`, `select`, and `reduce`
### Pure functions
### Composition
### Immutable values
]
.right-column[
```ruby
def index(commit)
  elasticsearch.index(commit)
* log(commit)
end

def log(commit)
  puts commit.keep_if { |k, v|
    ['author', 'id'].include? k }
end
```

```ruby
def index(commit)
* log(commit)
  elasticsearch.index(commit)
end

# Now fields like 'commit_date' are
# stripped out before indexing!
```
]

???

Say you're indexing commits into Elasticsearch and you notice that some of them are failing, and they're not showing up in the logs because that `elasticsearch.index(commit)` line is throwing an exception.

You decide to move the `log` statement up, but then you're surprised to find that the only fields that are being indexed are `author` and `id`! What went wrong?

It turns out that `keep_if` mutates the commit in the `log` method. It doesn't look like a method that mutates its argument because it's not suffixed with `!`, but the name doesn't matter.

It's best to avoid mutation so that the caller doesn't need to worry about the variable changing.

So, in attempting to solve a bug, you've introduced another bug.
---
.center[![](images/bugs.png)]

???

Maybe a situation like that was the inspiration for this popular tweet.
---
# Moar correctness with static types

- ## Algebraic data types (no invalid representations of data)
- ## Banish ubiquitous nulls (Optional only when you want it)
- ## Limit effects in types (guarantee a file will be closed)

.center[![](images/cat.gif)]

???

Without static types, you can only go so far.

However, you can go much further with a type checker:

- Algebraic data types can help you model your data, preventing invalid representations
- Banish ubiquitous nulls (the Optional type provides the same behavior, but only when you want it)
- Limit effects in types (IO, state, concurrency, e.g. guarantee that an API call doesn't perform an HTTP DELETE, guarantee that a file will be closed)

I want to quickly show you guarantees that you can get with static types. Don't worry if you don't know how to read the Haskell-ish code, just try to follow along with the concepts.
---
.left-column[
### Banish null
]
.right-column[
## 1. Eliminate the keyword ~~null~~
## 2. Introduce the type `Optional a`

```haskell
data Optional a = None | Some a

divide : Int -> Int -> Optional Int
divide a 0 = None
divide a b = Some (a / b)

case (divide 3 0) of
  None -> "failed, due to division by 0"
  Some x -> "succeeded"
```

## 4. PROFIT!!!
]

???

The first step to banishing `null` is to completely eradicate it from your language.

The second step is to introduce the type `Optional a`.

There is no step 3. Go straight to profit.

The caller is forced to case split on `Optional`s.
---
.left-column[
### Banish null
### Algebraic data types
]
.right-column[
```haskell
data Shape = Circle Float
           | NGon Int Float
           | Text String

bad : Shape
bad = Text 3 -- COMPILE ERROR

radius : Shape -> Optional Float
radius (Circle r) = Some r
radius (NGon _ r) = Some r
radius _          = None
```
]

???

Compared to traditional OO classes, algebraic data types help prevent invalid representations of data without sacrificing ease of writing new functions for a type.

You can read this as "A shape is either a circle with radius, ngon with side count and radius, or text with a string".

Attempting to create a `Text 3` fails, and it's easy to add a new function `radius`.

And it's still easy to write a new function `radius` which takes a shape and returns an `Optional Float` when the shape doesn't have a natural radius.
---
.left-column[
### Banishing null
### Algebraic data types
### Limiting effects
]
.right-column[
## These functions CANNOT perform IO!

```haskell
length : String -> Int
first : List a -> Optional a
```

## These CAN
```haskell
getLine : IO String
printLine : String -> IO ()
```
]

???

In Haskell, you can tell whether or not a function performs IO **just by looking at the return type**.

As long as the return type does not contain IO, the function cannot delete all the files on your hard drive, or worse, upload them somewhere over the network.
---
# Learning Haskell
# More approachable: Learn You a Haskell
.center[.smaller20[![](images/lyah.png)]]
# More academic: https://github.com/bitemyapp/learnhaskell

???

If you're interested in learning Haskell, the most approachable Haskell book is Learn You a Haskell, and a more academic route is @bitemyapp's guide.

And of course, feel free to ask me any questions you might have.
    </textarea>
    <script src="https://gnab.github.io/remark/downloads/remark-latest.min.js"> </script>
    <script>
      var slideshow = remark.create({
          ratio: '16:9',
          highlightStyle: 'monokai',
          highlightLanguage: 'remark',
          highlightLines: true
        }) ;
    </script>
  </body>
</html>
