
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="keywords" content="remark,remarkjs,markdown,slideshow,presentation" />
    <meta name="description" content="A simple, in-browser, markdown-driven slideshow tool." />
    <title>Strategies for code correctness inspired by functional programming</title>
    <style>
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif);
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body {
        font-family: 'Droid Serif';
      }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: 400;
        margin-bottom: 0;
      }
      .remark-slide-content {
        padding-left: 2em;
        padding-right: 2em;
        padding-top: 0em;
      }
      .remark-slide-content h1 { font-size: 3em; }
      .remark-slide-content h2 { font-size: 2em; }
      .remark-slide-content h3 { font-size: 1.6em; }
      .footnote {
        position: absolute;
        bottom: 3em;
      }
      li p { line-height: 1.25em; }
      .red { color: #fa0000; }
      .large { font-size: 2em; }
      a, a > code {
        color: rgb(249, 38, 114);
        text-decoration: none;
      }
      code {
        background: #e7e8e2;
        border-radius: 5px;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
      .remark-code { font-size: 120%; }
      .remark-code-line-highlighted     { background-color: #373832; }
      .pull-left {
        float: left;
        width: 47%;
      }
      .pull-right {
        float: right;
        width: 47%;
      }
      .pull-right ~ p {
        clear: both;
      }
      #slideshow .slide .content code {
        font-size: 0.8em;
      }
      #slideshow .slide .content pre code {
        font-size: 0.9em;
        padding: 15px;
      }
      .inverse {
        background: #272822;
        color: #777872;
        text-shadow: 0 0 20px #333;
      }
      .inverse h1, .inverse h2 {
        color: #f3f3f3;
        line-height: 0.8em;
      }

      /* Slide-specific styling */
      #slide-inverse .footnote {
        bottom: 12px;
        left: 20px;
      }
      #slide-how .slides {
        font-size: 0.9em;
        position: absolute;
        top:  151px;
        right: 140px;
      }
      #slide-how .slides h3 {
        margin-top: 0.2em;
      }
      #slide-how .slides .first, #slide-how .slides .second {
        padding: 1px 20px;
        height: 90px;
        width: 120px;
        -moz-box-shadow: 0 0 10px #777;
        -webkit-box-shadow: 0 0 10px #777;
        box-shadow: 0 0 10px #777;
      }
      #slide-how .slides .first {
        background: #fff;
        position: absolute;
        top: 20%;
        left: 20%;
        z-index: 1;
      }
      #slide-how .slides .second {
        position: relative;
        background: #fff;
        z-index: 0;
      }

      /* Two-column layout */
      .left-column {
        color: #777;
        width: 20%;
        height: 92%;
        float: left;
      }
        .left-column h2:last-of-type, .left-column h3:last-child {
          color: #000;
        }
      .right-column {
        width: 75%;
        float: right;
        padding-top: 0.5em;
        font-size: 125%;
      }
      .smaller img {
          width: 15%;
          height: auto;
      }
    </style>
  </head>
  <body>
    <textarea id="source">
layout: true
class: center, middle
---
# Strategies for code correctness

![](images/function.png)

## Inspired by functional programming

???

Many concepts associated with functional programming (like pure functions, static typing, immutability, and limiting side effects) reduce the ability of different parts of a program to affect each other in unintended ways. Because of this, programs written in a functional style tend to be less prone to bugs.

Since "strategies for code correctness" is a highly requested topic for these All-Hands meetings, I would like to show you some of these concepts and how you might use them in your own programs.
---
# Chris Wendt - @chrismwendt

![](images/contributions.png)

.smaller[![](images/repository-chart.png)] ![](images/haskell.png)

![](images/idris.png)

???

I'm @chrismwendt, and as evidenced by my contributions graph, I joined GitHub about 2 months ago. I work with Tim Pease and Grant Rodgers on the Search team.

Haskell was my introduction to functional programming about 2 years ago, and now almost half of my projects are written in it. More recently, I've dabbled in Idris, a language in which you can embed proofs into your programs that get checked at compile time.

Ok, now let's take a look at a few examples of how a functional programming style can be applied to Ruby to reduce complexity and avoid bugs.
---
layout: false
.left-column[
### `map`, `select`, and `reduce`
]
.right-column[
```ruby
def sum_of_even_squares(array)
  sum = 0
  for n in array
    square = n * n
    if square.even?
      sum += square
    end
  end
  sum
end
```

```ruby
def sum_of_even_squares(array)
  array
    .map { |n| n * n }
    .select { |n| n.even? }
    .reduce(0) { |sum, n| sum + n }
end
```
]

???

Here we have 2 implementations of a function which calculates the sum of the even squares of numbers in an array.

The first takes an imperative approach, with the mutable variable `sum`, a `for` loop, and the addition statement guarded by an `if`.

The second takes a declarative approach by employing composability, lambdas, and the common array transformation functions `map`, `select`, and `reduce`.

The functional version is:

- More visually appealing with less nesting
- Simpler because there are fewer variables in scope
- Simpler because the scopes of the transformations are isolated from each other
- Easier to modify (for example, returning just the even squares would be as simple as removing the `reduce` line)

The functional version requires you to know about `map`, `select`, and `reduce`, but the benefit of making it easier to understand once you do is worth it because these functions are so common.
---
.left-column[
### `map`, `select`, and `reduce`
### Pure functions
]
.right-column[
```ruby
def truncate_lines
  n = ARGV[0].to_i
  puts($stdin.readlines.map { |line| line[0...n] })
end

def main
  truncate_lines
end
```

```ruby
def truncate_lines(n, lines)
  lines.map { |line| line[0...n] })
end

def main
  puts(truncate_lines(ARGV[0].to_i, $stdin.readlines))
end
```
]

???

Here we have 2 implementations of a program which truncates lines from `stdin` to the length specified by a command line argument.

The first mixes IO with pure computation, and is unnecessarily difficult to test because of that. You would have to run this program in a separate process to test it. `truncate_lines` is **impure** because it reads external state and performs side effects, namely reading from `ARGV` and `stdin`, and writing to `stdout`. Also, it's not a function because it doesn't take arguments. It's more appropriately called a "procedure", "subroutine", or "action".

The second implementation restricts all of the IO to the main method, cleanly extracting out the pure computation as the `truncate_lines` method. This `truncate_lines` is **pure** because it returns the same value given the same arguments.
---
.left-column[
### `map`, `select`, and `reduce`
### Pure functions
]
.right-column[
## Pure
- Math `+`, `cos`, `sqrt`
- String operations `split`, `MD5.hexdigest`, `reverse`

```ruby
assert(truncate_lines(2, ["s", "sbm"]) == ["s", "sb"])
```

## Impure
- IO `gets`, `File.write`, `HTTP::get`, `%x{rm -rf /}`
- Nondeterminism `rand`, `Time.now`
- `$global` mutable state
]

???

A pure function is one which returns the same value given the same arguments, and does not cause side effects. **Examples**

When you can, try to separate pure functions from impure code because pure functions are:

- Easier to test: call them and check the return value.

- Portable since their only dependencies are their arguments, not the presence of a file, a database, or a web service.

- Trivially parallelizable and their return values are cacheable.
---
.left-column[
### `map`, `select`, and `reduce`
### Pure functions
### Composition
]
.right-column[
```ruby
def parse_query(string)
  filters = []
  until scanner.eos?
    if scanner.scan('([a-z]+):([a-z]+)')
      filters << {
        :key   => scanner[0],
        :value => scanner[1] }
    elsif ...
  end
  filters
end
```

```ruby
class QueryParser < Parslet::Parser
  rule(:word) { match('[a-z]+') }
  rule(:filter) { (word.as(:key) >>
    word.as(:value)).as(:filter) }
  rule(:query) { (filter | ...).repeat }
  root(:query)
end
```
]

???

Now for a real-world example: parsing the query from the text in a search box on GitHub. These examples were gleaned from real production code, and the new version is currently being developed.

The old version parses a string as a query directly by scanning for matching regexes and appends them to an array until the end of string is reached.

The old version is not composable, so it cannot be easily reused. For example, you couldn't implement nested filters (like and, or, not) by calling `parse_query` recursively.

The new version uses a parser expression library to define the parser. With this approach, the query parser is built up by starting with primitive parsers (like a literal string, or here a regex), and combining parsers together in various ways (like sequencing and alternation).
---
.left-column[
### `map`, `select`, and `reduce`
### Pure functions
### Composition
### Immutable values
]
.right-column[
```ruby
def index(commit)
  elasticsearch.index(commit)
* log(commit)
end

def log(commit)
  puts commit.keep_if { |k, v|
    ['author', 'id'].include? k }
end
```

```ruby
def index(commit)
* log(commit)
  elasticsearch.index(commit)
end

# Now fields like 'commit_date' are
# stripped out before indexing!
```
]

???

Say you're indexing commits into Elasticsearch and you notice that some of the documents are failing to be indexed, and they're not showing up in the logs because the index operation is throwing an exception.

You decide to put the `log` statement first, but now fields like `commit_date` are not being indexed! What's wrong?

`keep_if` mutates the commit in the `log` method. It doesn't look like a method that mutates its argument because it's not suffixed with `!`, but the name doesn't matter.

In attempting to solve a bug, you've introduced another bug.

Other rambling thoughts:

Thread safety
Parallelism
Traditional object references conflate value with identity
Java ConcurrentModificationException
You KNOW what the value of `x` is in its entire scope
Mutation is useful in some cases, VENN DIAGRAM IT
Since mutation is the default, it's present way more often than it's useful
mutability present
mutability appropriate
immutability used

sum = 0
sum += a[i]
This is a lie, and renaming it to `sum_so_far` is weird "I thought you were returning me the SUM!?"

Although you can't limit mutation in Ruby, you can limit its scope.

DON'T STORE MUTABLE VALUES IN CLASS MEMBERS

You can trivially pass an immutable value to another function and not have to worry about it mutating it.

---
.center[![](images/bugs.png)]

???

Maybe a situation like that was the inspiration for this popular tweet.
---
# Moar correctness with static types

- ## Algebraic data types (no invalid representations of data)
- ## Banish ubiquitous nulls (Optional only when you want it)
- ## Limit effects in types (guarantee a file will be closed)

.center[
![](images/cat.gif)
]

???

That was a whirlwind tour of what you can do to reduce the chance of bugs in your programs, without introducing a different language with static types.

However, you can go much further with a type checker:

- Algebraic data types can help model your data, avoiding invalid representations
- Banish ubiquitous nulls (the Optional type provides the same behavior, but only when you want it)
- Limit effects in types (IO, state, concurrency, e.g. guarantee that an API call doesn't perform an HTTP DELETE, guarantee that a file will be closed)

MORE SLIDES! show ADTs, explain nulls, and IO return type limits

Feel free to talk to robrix or I

Shout out to production plans that are going down this path of types

Include links to LYAH and bitemyapp's guide to starting Haskell
    </textarea>
    <script src="https://gnab.github.io/remark/downloads/remark-latest.min.js"> </script>
    <script>
      var slideshow = remark.create({
          ratio: '16:9',
          highlightStyle: 'monokai',
          highlightLanguage: 'remark',
          highlightLines: true
        }) ;
    </script>
  </body>
</html>
